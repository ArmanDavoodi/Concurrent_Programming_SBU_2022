#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>

using namespace std;

#define USE_CUDA false // if true uses cuda else serial implementation is used
//#define DEBUG // if defined the matrices are printed after the calculation.

constexpr int RUN_COUNT = 1; // number of runs
constexpr int MULT_BLOCK_SIZE = 16; // same as Block width/height
constexpr int AD_HOC = 64;
const char path[300] = "test4096"; // input file path

int N; // size of matrices => A(N x N) . B(N x N) = C(N x N)
double elapsed_t = 0.0;

void loadMatrices(int*& a, int*& b, int*& c); // reads matrices from file generated by matrixGenerator.cpp
void printMatrices(int* a, int* b, int* c);

// computes dot product of A and B and stores the result in C
cudaError_t cudaStrassen(int* h_A, int* h_B, int* h_C);
cudaError_t cudaStrassen(int* d_A, int* d_B, int* d_C, int n
    , int xa, int ya, int xb, int yb);

// this method computed a.b and stores it in c. n is the size of matrices, xa and ya are respectively
//   the index of the first row and first column of matrix a. xb and yb are similar to xa and ya.
void strassenSequentialProduct(int** a, int** b, int**& c, int n
    , int xa = 0, int ya = 0, int xb = 0, int yb = 0, bool computeTime = false);

// this method computes a+b and stores the resault in matrix c. 
void sequentialSquareMatrixAddition(int** a, int** b, int**& c, int n
    , int xa, int ya, int xb, int yb, int xc = 0, int yc = 0);

// this method computes a-b and stores the resault in matrix c.
void sequentialSquareMatrixSubtraction(int** a, int** b, int**& c, int n
    , int xa, int ya, int xb, int yb, int xc = 0, int yc = 0);

cudaError_t cudaAllocate(int*& device_mem, int n);
cudaError_t cudaCopyHtD(int*& device_mem, int*& host_mem, int n);

__global__ void cudaMultKernel(int* d_a, int* d_b, int* d_c, int n
    , int xa, int ya, int xb, int yb, int xc, int yc)
{
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int column = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < n && column < n)
    {
        int tempSum = 0;

        // each thread computes one element of the result matrix
        for (int i = 0; i < n; ++i)
            tempSum += d_a[(row + xa) * n + (i + ya)] * d_b[(i + xb) * n + (column + yb)];
        d_c[(row + xc) * n + (column + yc)] = tempSum;
    }
}

__global__ void cudaAddKernel(int* d_a, int* d_b, int* d_c, int n
    , int xa, int ya, int xb, int yb, int xc, int yc)
{
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int column = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < n && column < n)
    {
        d_c[(row + xc) * n + (column + yc)] = d_a[(row + xa) * n + (column + ya)] + d_b[(row + xb) * n + (column + yb)];
    }
}

__global__ void cudaSubKernel(int* d_a, int* d_b, int* d_c, int n
    , int xa, int ya, int xb, int yb, int xc, int yc)
{
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int column = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < n && column < n)
    {
        d_c[(row + xc) * n + (column + yc)] = d_a[(row + xa) * n + (column + ya)] - d_b[(row + xb) * n + (column + yb)];
    }
}

int main()
{
    int* a = NULL;
    int* b = NULL;
    int* c = NULL;

    printf("loading matrices from file...\n");
    loadMatrices(a, b, c);

    int** sa = new int* [N], ** sb = new int* [N], ** sc = new int* [N];
    for (int i = 0; i < N; ++i)
    {
        sa[i] = new int[N];
        sb[i] = new int[N];
        sc[i] = new int[N];

        for (int j = 0; j < N; ++j)
        {
            sa[i][j] = a[i * N + j];
            sb[i][j] = b[i * N + j];
            sc[i][j] = c[i * N + j];
        }
    }

    printf("N = %d\n", N);
    #if USE_CUDA == true
        printf("using CUDA ");
    #else
        printf("Sequential Algorithm...\n");
    #endif

    for (int i = 0; i < RUN_COUNT; ++i)
    {
        #if USE_CUDA == true
            // compute dot product of matrices in parallel.
            cudaError_t cudaStatus = cudaStrassen(a, b, c);
            if (cudaStatus != cudaSuccess) {
                printf("addWithCuda failed!");
                return 1;
            }
        #else
            strassenSequentialProduct(sa, sb, sc, N, 0, 0, 0, 0, true);
            #ifdef DEBUG
                for (int i = 0; i < N; ++i)
                {
                    for (int j = 0; j < N; ++j)
                    {
                        c[i * N + j] = sc[i][j];
                    }
                }
            #endif
        #endif
    }

    printf("with run count of %d, has average elapsed time of %f seconds\n", RUN_COUNT, elapsed_t / RUN_COUNT);

#ifdef DEBUG
    printMatrices(a, b, c);
#endif

    free(a);
    free(b);
    free(c);
    for (int i = 0; i < N; ++i)
    {
        delete[] sa[i];
        delete[] sb[i];
        delete[] sc[i];
    }
    delete[] sa;
    delete[] sb;
    delete[] sc;

    #if USE_CUDA == true
        // cudaDeviceReset must be called before exiting in order for profiling and
        // tracing tools such as Nsight and Visual Profiler to show complete traces.
        cudaError_t cudaStatus = cudaDeviceReset();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceReset failed!");
            return 1;
        }
    #endif

    return 0;
}

void loadMatrices(int*& a, int*& b, int*& c)
{

    FILE* fp = fopen(path, "r");

    fscanf(fp, "%d", &N);
    fscanf(fp, "%d", &N);

    fscanf(fp, "%d", &N);

    a = (int*)malloc(N * N * sizeof(int));
    b = (int*)malloc(N * N * sizeof(int));
    c = (int*)malloc(N * N * sizeof(int));

    if (a == NULL || b == NULL || c == NULL) {
        printf("Memory not allocated.\n");
        exit(0);
    }

    for (int i = 0; i < N * N; ++i)
    {
        fscanf(fp, "%d", a + i);
    }

    for (int i = 0; i < N * N; ++i)
    {
        fscanf(fp, "%d", b + i);
        c[i] = 0;
    }

    fclose(fp);

    printf("\n#### Matrices loaded succesfully! ####\n\n");
}

void printMatrices(int* a, int* b, int* c)
{
    printf("Size = %d\n", N);

    printf("A:\n");
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
            printf("\t%d ", a[i * N + j]);
        printf("\n");
    }

    printf("\nB:\n");
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
            printf("\t%d ", b[i * N + j]);
        printf("\n");
    }


    printf("\nC:\n");
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
            printf("\t%d ", c[i * N + j]);
        printf("\n");
    }

    printf("\n#### Done ####\n\n");
}

void sequentialMult(const int* a, const int* b, int* c)
{
    auto start = omp_get_wtime();
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            c[i * N + j] = 0;
            for (int t = 0; t < N; ++t)
            {
                c[i * N + j] += a[i * N + t] * b[t * N + j];
            }
        }
    }
    elapsed_t += omp_get_wtime() - start;
}

cudaError_t cudaStrassen(int* d_A, int* d_B, int* d_C, int n
    , int xa, int ya, int xb, int yb)
{

    dim3 threadsPerBlock(MULT_BLOCK_SIZE, MULT_BLOCK_SIZE);
    cudaError_t cudaStatus;

    if (n <= AD_HOC)
    {
        dim3 blocksPerGrid(ceil((double)n / (double)threadsPerBlock.x), ceil((double)n / (double)threadsPerBlock.y));
        cudaMultKernel<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_B, d_C, n, xa, ya, xb, yb, 0, 0);
    }
    else
    {
        int dividedSize = n / 2;
        dim3 blocksPerGrid(ceil((double)dividedSize / (double)threadsPerBlock.x), ceil((double)dividedSize / (double)threadsPerBlock.y));

        int** s = new int* [10];
        for (int i = 0; i < 10; ++i)
        {
            cudaAllocate(s[i], dividedSize * dividedSize);
        }
        int** p = new int* [7];
        for (int i = 0; i < 7; ++i)
        {
            cudaAllocate(p[i], dividedSize * dividedSize);
        }

        cudaSubKernel<<<blocksPerGrid, threadsPerBlock>>>(d_B, d_B, s[0], dividedSize, xb, yb + dividedSize
            , xb + dividedSize, yb + dividedSize, 0, 0);

        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_A, s[1], dividedSize, xa, ya, xa, ya + dividedSize, 0, 0);

        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_A, s[2], dividedSize, xa + dividedSize, ya
            , xa + dividedSize, ya + dividedSize, 0, 0);

        cudaSubKernel<<<blocksPerGrid, threadsPerBlock>>>(d_B, d_B, s[3], dividedSize, xb + dividedSize, yb, xb, yb, 0, 0);

        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_A, s[4], dividedSize, 
            xa, ya, xa + dividedSize, ya + dividedSize, 0, 0);

        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(d_B, d_B, s[5], dividedSize, 
            xb, yb, xb + dividedSize, yb + dividedSize, 0, 0);

        cudaSubKernel<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_A, s[6], dividedSize, xa, ya + dividedSize
            , xa + dividedSize, ya + dividedSize, 0, 0);

        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(d_B, d_B, s[7], dividedSize, xb + dividedSize, yb
            , xb + dividedSize, yb + dividedSize, 0, 0);

        cudaSubKernel<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_A, s[8], dividedSize, xa, ya, xa + dividedSize, ya, 0, 0);

        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(d_B, d_B, s[9], dividedSize, xb, yb, xb, yb + dividedSize, 0, 0);

        /*cudaStatus = cudaDeviceSynchronize();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
            exit(EXIT_FAILURE);
        }*/

        // recursive calls(computing P matrices)
        cudaStrassen(d_A, s[0], p[0], dividedSize, xa, ya, 0, 0);
        cudaStrassen(s[1], d_B, p[1], dividedSize, 0, 0, xb + dividedSize, yb + dividedSize);
        cudaStrassen(s[2], d_B, p[2], dividedSize, 0, 0, xb, yb);
        cudaStrassen(d_A, s[3], p[3], dividedSize, xa + dividedSize, ya + dividedSize, 0, 0);
        cudaStrassen(s[4], s[5], p[4], dividedSize, 0, 0, 0, 0);
        cudaStrassen(s[6], s[7], p[5], dividedSize, 0, 0, 0, 0);
        cudaStrassen(s[8], s[9], p[6], dividedSize, 0, 0, 0, 0);

        /*cudaStatus = cudaDeviceSynchronize();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
            exit(EXIT_FAILURE);
        }*/

        // computing C11
        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(p[4], p[3], d_C, dividedSize, 0, 0, 0, 0, 0, 0);

        /*cudaStatus = cudaDeviceSynchronize();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
            exit(EXIT_FAILURE);
        }*/

        cudaSubKernel<<<blocksPerGrid, threadsPerBlock>>>(d_C, p[1], d_C, dividedSize, 0, 0, 0, 0, 0, 0);

        /*cudaStatus = cudaDeviceSynchronize();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
            exit(EXIT_FAILURE);
        }*/

        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(d_C, p[5], d_C, dividedSize, 0, 0, 0, 0, 0, 0);

        // computing C12
        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(p[0], p[1], d_C, dividedSize, 0, 0, 0, 0, 0, dividedSize);

        // computing C21
        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(p[2], p[3], d_C, dividedSize, 0, 0, 0, 0, dividedSize, 0);

        // computing C22
        cudaAddKernel<<<blocksPerGrid, threadsPerBlock>>>(p[4], p[0], d_C, dividedSize, 0, 0, 0, 0, dividedSize, dividedSize);
        
        /*cudaStatus = cudaDeviceSynchronize();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
            exit(EXIT_FAILURE);
        }*/
        
        cudaSubKernel<<<blocksPerGrid, threadsPerBlock>>>(d_C, p[2], d_C, dividedSize
            , dividedSize, dividedSize, 0, 0, dividedSize, dividedSize);

        /*cudaStatus = cudaDeviceSynchronize();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
            exit(EXIT_FAILURE);
        }*/

        cudaSubKernel<<<blocksPerGrid, threadsPerBlock>>>(d_C, p[6], d_C, dividedSize
            , dividedSize, dividedSize, 0, 0, dividedSize, dividedSize);

        cudaStatus = cudaDeviceSynchronize();
        if (cudaStatus != cudaSuccess) {
            printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < 10; ++i)
        {
            cudaFree(s[i]);
        }
        delete[] s;
        s = nullptr;

        for (int i = 0; i < 7; ++i)
        {
            cudaFree(p[i]);
        }
        delete[] p;
        p = nullptr;
    }

    return cudaError_t();
}


cudaError_t cudaStrassen(int* h_A, int* h_B, int* h_C)
{
    int* d_A = 0;
    int* d_B = 0;
    int* d_C = 0;
    cudaError_t cudaStatus;

    cudaAllocate(d_A, N * N);
    cudaAllocate(d_B, N * N);
    cudaAllocate(d_C, N * N);

    cudaCopyHtD(d_A, h_A, N * N);
    cudaCopyHtD(d_B, h_B, N * N);

    cudaEvent_t start, stop;
    cudaEventCreate(&start);
    cudaEventCreate(&stop);

    cudaEventRecord(start, NULL);
    cudaStrassen(d_A, d_B, d_C, N, 0, 0, 0, 0);
    cudaEventRecord(stop, NULL);

    cudaStatus = cudaGetLastError();
    if (cudaStatus != cudaSuccess) {
        printf("addKernel launch failed: %s\n", cudaGetErrorString(cudaStatus));
        exit(EXIT_FAILURE);
    }
    cudaEventSynchronize(stop);
    float ms;
    cudaEventElapsedTime(&ms, start, stop);
    elapsed_t += ms / 1000;

    // cudaDeviceSynchronize waits for the kernel to finish, and returns
    // any errors encountered during the launch.
    cudaStatus = cudaDeviceSynchronize();
    if (cudaStatus != cudaSuccess) {
        printf("cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
        exit(EXIT_FAILURE);
    }

    // Copy output vector from GPU buffer to host memory.
    cudaStatus = cudaMemcpy(h_C, d_C, N * N * sizeof(int), cudaMemcpyDeviceToHost);
    if (cudaStatus != cudaSuccess) {
        printf("cudaMemcpy failed!");
        exit(EXIT_FAILURE);
    }

    cudaFree(d_C);
    cudaFree(d_A);
    cudaFree(d_B);

    return cudaStatus;
}

void strassenSequentialProduct(int** a, int** b, int**& c, int n
    , int xa, int ya, int xb, int yb, bool computeTime)
{
    double startTime = 0.0;
    if (computeTime)
        startTime = omp_get_wtime();

    if (n <= AD_HOC)
    {
        // naive algorithm
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < n; ++j)
            {
                c[i][j] = 0;
                for (int k = 0; k < n; ++k)
                {
                    c[i][j] += a[i + xa][k + ya] * b[k + xb][j + yb];
                }
            }
        }
    }
    else
    {
        // strassen algorithm
        int dividedSize = n / 2;
        int*** s = new int** [10];
        for (int i = 0; i < 10; ++i)
        {
            s[i] = new int* [dividedSize];
            for (int j = 0; j < dividedSize; ++j)
            {
                s[i][j] = new int[dividedSize];
            }
        }

        sequentialSquareMatrixSubtraction(b, b, s[0], dividedSize, xb, yb + dividedSize
            , xb + dividedSize, yb + dividedSize);

        sequentialSquareMatrixAddition(a, a, s[1], dividedSize, xa, ya, xa, ya + dividedSize);

        sequentialSquareMatrixAddition(a, a, s[2], dividedSize, xa + dividedSize, ya
            , xa + dividedSize, ya + dividedSize);

        sequentialSquareMatrixSubtraction(b, b, s[3], dividedSize, xb + dividedSize, yb, xb, yb);

        sequentialSquareMatrixAddition(a, a, s[4], dividedSize, xa, ya, xa + dividedSize, ya + dividedSize);

        sequentialSquareMatrixAddition(b, b, s[5], dividedSize, xb, yb, xb + dividedSize, yb + dividedSize);

        sequentialSquareMatrixSubtraction(a, a, s[6], dividedSize, xa, ya + dividedSize
            , xa + dividedSize, ya + dividedSize);

        sequentialSquareMatrixAddition(b, b, s[7], dividedSize, xb + dividedSize, yb
            , xb + dividedSize, yb + dividedSize);

        sequentialSquareMatrixSubtraction(a, a, s[8], dividedSize, xa, ya, xa + dividedSize, ya);

        sequentialSquareMatrixAddition(b, b, s[9], dividedSize, xb, yb, xb, yb + dividedSize);

        // recursive calls(computing P matrices)
        strassenSequentialProduct(a, s[0], s[0], dividedSize, xa, ya, 0, 0);
        strassenSequentialProduct(s[1], b, s[1], dividedSize, 0, 0, xb + dividedSize, yb + dividedSize);
        strassenSequentialProduct(s[2], b, s[2], dividedSize, 0, 0, xb, yb);
        strassenSequentialProduct(a, s[3], s[3], dividedSize, xa + dividedSize, ya + dividedSize, 0, 0);
        strassenSequentialProduct(s[4], s[5], s[4], dividedSize);
        strassenSequentialProduct(s[6], s[7], s[5], dividedSize);
        strassenSequentialProduct(s[8], s[9], s[6], dividedSize);

        // computing C11
        sequentialSquareMatrixAddition(s[4], s[3], c, dividedSize, 0, 0, 0, 0, 0, 0);
        sequentialSquareMatrixSubtraction(c, s[1], c, dividedSize, 0, 0, 0, 0, 0, 0);
        sequentialSquareMatrixAddition(c, s[5], c, dividedSize, 0, 0, 0, 0, 0, 0);

        // computing C12
        sequentialSquareMatrixAddition(s[0], s[1], c, dividedSize, 0, 0, 0, 0, 0, dividedSize);

        // computing C21
        sequentialSquareMatrixAddition(s[2], s[3], c, dividedSize, 0, 0, 0, 0, dividedSize, 0);

        // computing C22
        sequentialSquareMatrixAddition(s[4], s[0], c, dividedSize, 0, 0, 0, 0, dividedSize, dividedSize);
        sequentialSquareMatrixSubtraction(c, s[2], c, dividedSize
            , dividedSize, dividedSize, 0, 0, dividedSize, dividedSize);
        sequentialSquareMatrixSubtraction(c, s[6], c, dividedSize
            , dividedSize, dividedSize, 0, 0, dividedSize, dividedSize);

        for (int i = 0; i < 10; ++i)
        {
            for (int j = 0; j < dividedSize; ++j)
            {
                delete[] s[i][j];
                s[i][j] = nullptr;
            }
            delete[] s[i];
            s[i] = nullptr;
        }
        delete[] s;
        s = nullptr;
    }

    if (computeTime)
        elapsed_t = omp_get_wtime() - startTime;
}

void sequentialSquareMatrixAddition(int** a, int** b, int**& c, int n
    , int xa, int ya, int xb, int yb, int xc, int yc)
{
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            c[i + xc][j + yc] = a[i + xa][j + ya] + b[i + xb][j + yb];
}

void sequentialSquareMatrixSubtraction(int** a, int** b, int**& c, int n
    , int xa, int ya, int xb, int yb, int xc, int yc)
{
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            c[i + xc][j + yc] = a[i + xa][j + ya] - b[i + xb][j + yb];
}


cudaError_t cudaAllocate(int*& device_mem, int n)
{
    cudaError_t cudaStatus = cudaMalloc((void**)&device_mem, n * sizeof(int));
    if (cudaStatus != cudaSuccess) {
        printf("cudaMalloc failed!");
        exit(EXIT_FAILURE);
    }
    return cudaStatus;
}

cudaError_t cudaCopyHtD(int*& device_mem, int*& host_mem, int n)
{
    cudaError_t cudaStatus = cudaMemcpy(device_mem, host_mem, n * sizeof(int), cudaMemcpyHostToDevice);
    if (cudaStatus != cudaSuccess) {
        printf("cudaMemcpy failed!");
        exit(EXIT_FAILURE);
    }
    return cudaStatus;
}